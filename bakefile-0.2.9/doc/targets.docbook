<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
    "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<!-- $Id: targets.docbook 1290 2009-02-26 22:32:00Z vaclavslavik $ -->

<chapter id="ch.targets">
  <title>Targets</title>
  <para id="targets">
    Bakefile targets correspond to native makefile targets: they are compiled
    programs, libraries, or more complex actions such as "install" or "dist".
    Target syntax is similar to <link linkend="ch.commands">command</link>
    syntax:
    <programlisting><![CDATA[
<TYPE id="NAME" [template="TEMPLATE,..."] [template_append="TEMPLATE,..."]
      [cond="CONDITION"] [category="CATEGORY"]>
  SPECIFICATION
</TYPE>
]]></programlisting>
  </para>

  <para>
    There are six standard target types: <xref linkend="rule.exe"/>,
    <xref linkend="rule.dll"/>, <xref linkend="rule.module"/>,
    <xref linkend="rule.lib"/>, <xref linkend="rule.phony"/> and
    <xref linkend="rule.action"/>. You can define a new "rule"
    (that is, a target type) based on one of the standard rules
    using the <xref linkend="cmd.define-rule"/> command.
  </para>
  <para>
    Each target requires a unique <varname>id</varname>. This ID is usually
    present in the generated makefile, so you can type <userinput>make
    myprogram</userinput> to create the target with the ID
    <literal>myprogram</literal>. The target's ID also controls
    the name of the output file.
  </para>
  <para>
    <varname>template</varname> is an optional comma-separated list of
    IDs of <link linkend="cmd.template">templates</link> that the target is
    derived from. <varname>template_append</varname> is an optional
    comma-separated list of templates that are <emphasis>appended</emphasis>
    to the target specification. (<varname>template</varname> inserts the
    template before the specification).
  </para>
  <para>
    If the <varname>cond</varname> attribute is given, the target is only
    compiled if the named <link linkend="concept.conditions">condition</link>
    was met. (Follow that link to see the rules governing whether Bakefile
    evaluates the condition, or the native build system (e.g.
    <filename>make</filename>) evaluates it).
  </para>
  <para>
    In addition to the ID, every target can have
    <link linkend="concept.variables">variables</link> attached to it.
    These variables are only effective for the target; contrast global
    variables, which affect all targets. They can be used to override a
    global variable: for example, the <varname>DLLEXT</varname> variable
    is <literal>.dll</literal> for Windows makefiles, but you can override
    the variable locally for the <literal>sharpen_plugin</literal> target to
    be <literal>.plugin</literal>.
  </para>
  <para>
    Target is described using <varname>SPECIFICATION</varname>, which is a
    list of <xref linkend="cmd.set"/>
    commands and <emphasis>tags</emphasis>. Tags are rule-specific
    constructs, so they come in several forms: they can list source files for
    an executable, set include directories, or define compiler flags. Unlike
    <function>set</function>, they don't set any specific variable, but rather
    set various variables in a <emphasis>generator-specific way</emphasis>.
    Tag syntax is almost identical to the <function>set</function> function,
    but without a variable name:
    <programlisting><![CDATA[<TAGNAME>VALUE</TAGNAME>]]></programlisting>
  </para>
  <para>
    Common tags are described in
    <link linkend="rules">the section below</link>. Tags specific to
    particular modules are described in <xref linkend="ch.modules"/>.
    A small example of using tags:
    <programlisting><![CDATA[
<exe id="myprogram">
  <!-- set target-specific variable: -->
  <set var="SOME_VAR">value</set>
  <!-- three tags: -->
  <sources>file1.c myprogram.c utils.c</sources>
  <include>./includes</include>
  <define>USE_UNICODE</define>
</exe>
]]></programlisting>
    Unless the documentation says otherwise, you can use the same tag
    repeatedly with the same target.
  </para>
  <para>
    The optional <varname>category</varname> attribute can be given to classify
    the target. Possible classifications are <literal>all</literal> (reserved
    for the <literal>all</literal> target of makefiles and cannot be used
    in user Bakefiles), <literal>normal</literal> for targets declared in
    Bakefiles, and <literal>automatic</literal> for targets that are created
    as a side-effect of Bakefile's processing (e.g. object file targets).
    The targets are sorted in the generated makefile according to the category:
    the <literal>all</literal> target is first, followed by
    <literal>normal</literal> targets, and then <literal>automatic</literal>
    targets.
  </para>

  <note id="pseudotargets">
    <title>Pseudo targets</title>
    <para>
      Some rules don't declare real targets but so-called
      <emphasis>pseudo targets</emphasis>. Pseudo targets are processed as
      standard targets, but they don't appear in the generated makefile, have
      no action associated with them, can't depend on any other target, and
      can't be a dependency of another target. They can only modify the
      behavior of other targets. An example of a pseudo target is
      <xref linkend="rule.datafiles.data-files"/>.
    </para>
    <para>
      The advantage of pseudo targets is that the <varname>id</varname>
      attribute is not required. The disadvantage is that they can't be
      conditional.
    </para>
  </note>


  <section id="rules">
    <title>Standard Target Types ("Rules")</title>
    <para>
      Description of builtin rules and their tags follows. Additional rules
      and tags are defined by modules, see <xref linkend="ch.modules"/>.
    </para>

    <section id="rule.exe" xreflabel="exe">
      <title>exe</title>
      <para>
        Builds a program.
        <informaltable>
          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>

              <row id="tags.exe.app-type">
                <entry role="tagname">app-type</entry>
                <entry>
                  Use this tag to specify whether the executable is console
                  application (<literal>console</literal>) or windowed one
                  (<literal>gui</literal>). These two kinds of applications
                  are linked differently on Windows.
                  <programlisting><![CDATA[
<exe id="foo">
  <app-type>gui</app-type>
  <sources>foo.c bar.c</sources>
</exe>
]]></programlisting>
                </entry>
              </row>
              
              <row id="tags.lib.exename">
                <entry role="tagname">exename</entry>
                <entry>
                  Set name of the executable. By default, the name is same as
                  <varname>id</varname>, but it is sometimes useful to use
                  different name to identify the executable in makefiles
                  (<varname>id</varname>) and for created program file
                  (<varname>exename</varname>). Physical filename is
                  deriver from <varname>exename</varname> and format-specific
                  extension (e.g. <literal>.exe</literal> on Windows).
                </entry>
              </row>

              <row id="tags.exe.stack">
                <entry role="tagname">stack</entry>
                <entry>
                  Set the size of the stack on platforms where it is possible.
                  The default stack size varies for different platforms and
                  compilers. With too small stack you may get an error
                  indicating stack has overflowed. (Currently used by
                  <link linkend="format.watcom">Watcom format</link> only.)
                </entry>
              </row>

            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </section>
    
    
    
    <!-- =============================================================== -->
    <!--                               lib                               -->
    <!-- =============================================================== -->

    <section id="rule.lib" xreflabel="lib">
      <title>lib</title>
      <para>
        <informaltable>
          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>

              <row id="tags.lib.libname">
                <entry role="tagname">libname</entry>
                <entry>
                  Set name of the library. By default, the name is same as
                  <varname>id</varname>, but it is sometimes useful to use
                  different name to identify the library in makefiles
                  (<varname>id</varname>) and for created library file
                  (<varname>libname</varname>). This tag does
                  <emphasis>not</emphasis> set physical filename -- that is
                  derived from <varname>libname</varname> and other
                  generator-specific variables.
                  <programlisting><![CDATA[
<lib id="foo">
  <libname>foo$(COMPILER)_$(DBGFLAG)</libname>
  <sources>foo.c bar.c</sources>
</lib>
]]></programlisting>
                </entry>
              </row>
              
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </section>


    <!-- =============================================================== -->
    <!--                               dll                               -->
    <!-- =============================================================== -->
    
    <section id="rule.dll" xreflabel="dll">
      <title>dll</title>
      <para>
        
        <informaltable>
          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>

              <row id="tags.dll.dllname" xreflabel="dllname">
                <entry role="tagname">dllname</entry>                
                <entry>
                  Similar to <link linkend="tags.lib.libname">libname tag on
                    dll</link>, but it affects the name of shared library/DLL.
                </entry>
              </row>
              
              <row id="tags.dll.libname" xreflabel="libname">
                <entry role="tagname">libname</entry>
                <entry>
                  Similar to <xref linkend="tags.dll.dllname"/>, but used for
                  import library on Windows and .so symlink on Unix.
                </entry>
              </row>
              
              <row id="tags.dll.version" xreflabel="version">
                <entry role="tagname">version</entry>
                <entry>
                  Portable platform-independent shared library version.
                  <emphasis>Not yet implemented.</emphasis>
                </entry>
              </row>
              
              <row id="tags.dll.so_version" xreflabel="so_version">
                <entry role="tagname">so_version</entry>
                <entry>
                  <para>
                  The value consists of three numbers separated by dots.
                  Library name plus the first component of the version
                  together form <emphasis>soname</emphasis> (e.g.
                  <literal>libfoo.so.1</literal> on Linux) which is used
                  for runtime resolution of dependencies. Libraries with
                  different <emphasis>sonames</emphasis> are binary
                  incompatible and cannot be used interchangeable. On the
                  other hand, the remaining two components contain information
                  about minor versions that don't change backward
                  compatibility and aren't used by runtime linker.
                  </para>
                  <para>
                  Note that this version number is strictly for runtime
                  linker's use and for maintaining binary compatiblity, it
                  should <emphasis>not</emphasis> be version number of your
                  library.
                  </para>
                  <para>
                  This tag is only implemented in the
                  <literal>autoconf</literal> format.
                  </para>
                </entry>
              </row>
              
              <row id="tags.dll.mac_version" xreflabel="mac_version">
                <entry role="tagname">mac_version</entry>
                <entry>
                  <para>
                    This tag is used to specify shared library version for
                    runtime linker on Darwin platforms. Similarly to
                    <xref linkend="tags.dll.so_version"/>, it expects three
                    numbers separated by dots, but their interpretation is
                    different. The value is passed as-is to compilers
                    <literal>-current_version</literal> argument and the
                    first two components are passed to
                    <literal>--compatibility_version</literal>. See
                    See <ulink
                    url="http://developer.apple.com/documentation/Darwin/Reference/ManPages/man1/ld.1.html">Apple's
                    ld documentation</ulink> for details.
                  </para>
                  <para>
                  This tag is only implemented in the
                  <literal>autoconf</literal> and <literal>xcode2</literal>
                  formats.
                  </para>
                </entry>
              </row>
              
              
            </tbody>
          </tgroup>
        </informaltable>

      </para>
    </section>
    
    <!-- =============================================================== -->
    <!--                            module                               -->
    <!-- =============================================================== -->
    
    <section id="rule.module" xreflabel="module">
      <title>module</title>
      <para>
        Builds loadable module (aka plugin). Unlike <xref linkend="rule.dll"/>,
        this one does not create import library on Windows.
        <informaltable>
          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>

              <row id="tags.module.dllname" xreflabel="dllname">
                <entry role="tagname">dllname</entry>           
                <entry>
                  See <xref linkend="tags.dll.dllname"/>.
                </entry>
              </row>
              
            </tbody>
          </tgroup>
        </informaltable>

      </para>
    </section>
    
    
    <!-- =============================================================== -->
    <!--                            phony                                -->
    <!-- =============================================================== -->
    

    <section id="rule.phony" xreflabel="phony">
      <title>phony</title>
      <para>
        This type of target does nothing. It is usually used as convenience
        target together with <link linkend="tag.depends">depends</link> tag to
        easily build set of targets. Standard target <literal>all</literal>
        is an example of phony target.
      </para>
    </section>
    
    
    <!-- =============================================================== -->
    <!--                              action                             -->
    <!-- =============================================================== -->

    <section id="rule.action" xreflabel="action">
      <title>action</title>
      <para>
        This is most generic rule. It allows you to execute arbitrary sequence
        of commands when building the target and can therefore be used to
        extend Bakefile with custom build rules. Note that this rule is not
        platform- and compiler-independent as the rest of rules.
        <informaltable>
          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row id="tags.action.command" xreflabel="command">
                <entry role="tagname">command</entry>
                <entry>
                  <para>
                    Adds command to list of commands to be executed when
                    building the target.
                    <programlisting><![CDATA[
<action id="manual.html">
  <command>docbook2html manual.xml manual.html</command>
</action>
]]></programlisting>
                  </para>
                </entry>
              </row>
              
              <row id="tags.action.is-phony" xreflabel="is-phony">
                <entry role="tagname">is-phony</entry>
                <entry>
                  <para>
                    Marks the target as <emphasis>phony</emphasis>.
                    A phony target is target whose name is not really
                    the name of file produced by it, as is the case with
                    "standard" targets. Instead,
                    it's just a symbolic name for some commands to be
                    executed. In other words, this target should not be
                    considered by <literal>make</literal> when creating
                    the file dependency graph. For an example of why this
                    is useful, consider a
                    <literal>tags</literal> target that runs the Unix
                    <filename>ctags</filename> program. That
                    program creates a file called <filename>tags</filename>,
                    so after saying <computeroutput>make
                    tags</computeroutput> once, <filename>make</filename>
                    will always say that the tags target is up to date.
                    By marking the target as phony, you disable the file
                    dependency checking for it, so <computeroutput>make
                    tags</computeroutput> always runs the
                    <filename>ctags</filename> program.
                  </para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>
    </section>



    <!-- =============================================================== -->
    <!--                           subproject                            -->
    <!-- =============================================================== -->

    <section id="rule.subproject" xreflabel="subproject">
      <title>subproject</title>
      <para>
        Declares a subproject. This is typically another makefile in a
        subdirectory and is independent of its parent project. Therefore you
        can't use any variables or refer to targets from the parent project
        in a subproject.
        <informaltable>
          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Description</entry>
                <entry>Required/Default value</entry>
              </row>
            </thead>
            <tbody>
              <row id="tags.subproject.dir" xreflabel="dir">
                <entry role="tagname">dir</entry>
                <entry>
                  <para>
                    Directory containing subproject. Parent makefile calls
                    makefile in this directory.
                  </para>
                </entry>
                <entry role="default">required</entry>
              </row>
              <row id="tags.subproject.target" xreflabel="target">
                <entry role="tagname">target</entry>
                <entry>
                  <para>
                    Optional argument which specifies what target to build
                    in the subproject.
                  </para>
                </entry>
                <entry role="default"><literal>all</literal></entry>
              </row>
              <row id="tags.subproject.installable" xreflabel="installable">
                <entry role="tagname">installable</entry>
                <entry>
                  <para>
                    Whether <command>make install</command> (if supported by
                    the format) should descend into subproject's directory.
                    The value can only be <literal>yes</literal> or
                    <literal>no</literal> and must be a constant expression.
                  </para>
                </entry>
                <entry role="default"><literal>yes</literal></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </para>

      <para>
        Here is an example of how to use the subproject target:
        <programlisting><![CDATA[
<subproject id="examples">
  <dir>examples</dir>
  <installable>no</installable>
</subproject>
]]></programlisting>
      </para>
    </section>
  </section>




    
	<section id="sec.commontags">
		<title>Common tags</title>
		<para>
			These are tags you can use with any of the above target types.
			These tags are always available: it is not neccessary to load any
			<link linkend="ch.modules">module</link> to use them.

			<informaltable>
				<tgroup cols='3'>
					<thead>
						<row>
							<entry>Tag</entry>
							<entry>Description</entry>
							<entry>Availability</entry>
						</row>
					</thead>
					<tbody>
			
						<row id="tag.depends" xreflabel="depends">
							<entry role="tagname">depends</entry>
							<entry>
								<para>
									This tag is used to express target's dependency on other
									targets. All targets in the <function>depends</function>
									tag must be built prior to building this target. The value
									is whitespace-separated list of target IDs. It is an error
									to specify a nonexistent target here.
								</para>
								<para>
									Note that the <xref linkend="tag.library"/> tag implies
									<function>depends</function>.
								</para>
								<programlisting><![CDATA[
<exe id="app">
<sources>app.c</sources>
<depends>setup</depends>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">all rules</entry>
						</row>

						<row id="tag.dependency-of" xreflabel="dependency-of">
							<entry role="tagname">dependency-of</entry>
							<entry>
								Mark the target as dependency of target specified in tag's
								value. The value must be ID of existing target. This tag
								is opposite of <xref linkend="tag.depends"/>. Following two
								examples have identical effect:
								<programlisting><![CDATA[
<exe id="setup"></exe>
<exe id="app">
<depends>setup</depends>
</exe>
]]></programlisting><programlisting><![CDATA[
<exe id="app"></exe>
<exe id="setup">
<dependency-of>app</dependency-of>
</exe>
]]></programlisting>
							Note that only one of these tags should be used, it is not
							necessary to specify both of them.
							</entry>
							<entry role="availability">all</entry>
						</row>

						<row id="tag.headers" xreflabel="headers">
							<entry role="tagname">headers</entry>
							<entry>
                Specify (C/C++) header files used by the target.
								<programlisting><![CDATA[
<exe id="app">
  <headers>app.h</headers>
  <headers>utils.h additionalheader.h</headers>
  <sources>app.c</sources>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>


						<row id="tag.depends-on-file" xreflabel="depends-on-file">
							<entry role="tagname">depends-on-file</entry>
							<entry>
								Mark the target as depending on a given file. Use this
								when the dependency isn't one of the other declared
								targets. This can be useful for example when the dependency is
								generated by a script:
								<programlisting><![CDATA[
<action id="generated-header.h">
	<command>./header-generator.pl</command>
	<depends-on-file>header-generator.pl</depends-on-file>
</action>
]]></programlisting>
							  In this example, the header-generator.pl script creates
								generated-header.h. You would want the script to be
								re-run any time it changes, since the change probably
								would make it generate different contents for that
								header file. But since generated-header.pl is not itself
								generated by the makefile, you cannot use the <link
								linkend="tag.depends">depends</link> tag here.
							</entry>
							<entry role="availability">all</entry>
						</row>

						
						<row id="tag.objects-depend" xreflabel="objects-depend">
							<entry role="tagname">objects-depend</entry>
							<entry>
                Same as <xref linkend="tag.depends"/>, except the dependency
                is added to all <emphasis>object files</emphasis> used
                to build the target instead of to the target itself.
                This is useful e.g. in combination with precompiled
                headers (which must be generated before any source file
                is compiled) or when a commonly used header file is
                generated by the makefile.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						<row id="tags.lib.dirname">
							<entry role="tagname">dirname</entry>
							<entry>
								Set name of directory where the target will be created.
								<varname>BUILDDIR</varname> is used by default.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.sources" xreflabel="sources">
							<entry role="tagname">sources</entry>
							<entry>
								Specify source files used to build the target.
								<programlisting><![CDATA[
<exe id="app">
  <sources>app.c</sources>
  <sources>utils.c utils2.c</sources>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>

		
		
						<row id="tag.include" xreflabel="include">
							<entry role="tagname">include</entry>
							<entry>
								Add directory where the compiler should look for headers.
                This corresponds to the <literal>-I</literal> switch used by
                many compilers.
                Calls <xref linkend="tag.res-include"/> with the same value.
                Example:
                <programlisting><![CDATA[
<exe id="hello">
  <sources>hello.c</sources>
  <include>../include/foo</include>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
		
		
						<row id="tag.define" xreflabel="define">
							<entry role="tagname">define</entry>
							<entry>
								Define C preprocessor macro.
								The value may be empty, in which case no flag is added.
								Calls <xref linkend="tag.res-define"/> with same value.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
		
		
						<row id="tag.sys-lib" xreflabel="sys-lib">
							<entry role="tagname">sys-lib</entry>
							<entry>
								Link against specified library installed in the system. Note
								that this is <emphasis>not</emphasis> meant for linking in
								libraries that were built by the same makefile; use
								<xref linkend="tag.library"/> for that. This command links
								against a library installed in the system or provided by the
								compiler and corresponds to the <literal>-l</literal> switch
								of Unix compilers.
						<programlisting><![CDATA[
<exe id="png2bmp">
  <sources>png2bmp.c</sources>
  <sys-lib>png</sys-lib>
  <sys-lib>z</sys-lib>
</exe>
]]></programlisting>
								The library name may be empty. Only one library may be
								given as the tag's argument; the following usage is
								incorrect:
						<programlisting><![CDATA[
<exe id="png2bmp">
  <sources>png2bmp.c</sources>
  <sys-lib>png z</sys-lib> <!-- INCORRECT -->
</exe>
]]></programlisting>
								Note that the name of the library in this tag is
								<emphasis>not</emphasis> a file name and must not
								include paths. Use <xref linkend="tag.lib-path"/> to
								add a directory to the library search path.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>

						
						
						<row id="tag.lib-path" xreflabel="lib-path">
							<entry role="tagname">lib-path</entry>
							<entry>
								Add a directory to the search path used by the compiler
								to find <link linkend="tag.sys-lib">system
								libraries</link>. This corresponds to the
								<literal>-L</literal> switch of Unix compilers.
								Example:
						<programlisting><![CDATA[
<exe id="hello">
  <sources>hello.c</sources>
  <!-- note that hardcoding library paths like this is a bad
       idea, it's done here only for the sake of simplicity;
       in real bakefile, an <option> would be used -->
  <lib-path>/usr/lib/mysql</lib-path>
  <sys-lib>mysqlclient</sys-lib>
</exe>
]]></programlisting>
								On a typical Unix system, this asks the linker to link
								the <filename>hello</filename> program against
								<filename>libmysqlclient.so</filename> and to search for
								it in the directory <filename>/usr/lib/mysql</filename>
								in addition to any other directories the linker is
								configured to use.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
		
						
						
						
						<row id="tag.library" xreflabel="library">
							<entry role="tagname">library</entry>
							<entry>
								Link against library compiled by this makefile. The value
								passed to this tag must be name of existing target. Compare
								<xref linkend="tag.sys-lib"/>.
								<programlisting><![CDATA[
<lib id="mylib">
  <sources>lib1.c lib2.c</sources>
</lib>
<exe id="myapp">
  <sources>main.c</sources>
  <library>mylib</library>
  <sys-lib>X11</sys-lib>
  <sys-lib>GL</sys-lib>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
		
						
						<row id="tag.optimize" xreflabel="optimize">
							<entry role="tagname">optimize</entry>
							<entry>
								Set compiler's optimization level. May be one of
								<literal>off</literal> (no optimization),
								<literal>speed</literal> (generate fastest code) or
								<literal>size</literal> (smallest code).
								<programlisting><![CDATA[
<set var="OPTIMIZE_FLAG">
  <if cond="BUILD=='release'">speed</if>
  <if cond="BUILD=='debug'">off</if>
</set>
<exe id="myapp">
  <optimize>$(OPTIMIZE_FLAG)</optimize>
  <sources>main.c</sources>
  <sys-lib>GL</sys-lib>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						<row id="tag.debug-info" xreflabel="debug-info">
							<entry role="tagname">debug-info</entry>
							<entry>
								Enable or disable debugging information. Can be either
								<literal>on</literal> or <literal>off</literal>.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						<row id="tag.debug-runtime-libs" xreflabel="debug-runtime-libs">
							<entry role="tagname">debug-runtime-libs</entry>
							<entry>
								Enable or disable linking against debug version of C runtime.
								Can be either <literal>on</literal> or <literal>off</literal>
								and <emphasis>must</emphasis> appear after
								<xref linkend="tag.debug-info"/>. If not specified, then
								debug runtime libraries are used if and only if
								<xref linkend="tag.debug-info"/> was set to
								<literal>on</literal>. Note that this tag has effect only
								with Visual C++; other compilers respect only
								<xref linkend="tag.debug-info"/>.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
            
            
            
            <row id="tag.debug-info-edit-and-continue" xreflabel="debug-info-edit-and-continue">
							<entry role="tagname">debug-info-edit-and-continue</entry>
							<entry>
                Enable or disable additional debugging information to support
                <ulink
                  url="http://msdn.microsoft.com/en-us/library/bcew296c(VS.80).aspx">Edit
                  and Continue</ulink> feature of Visual C++ compilers.
                  Can be either
                  <literal>on</literal> or <literal>off</literal> (default).
                  Only supported by Visual C++ project files, does nothing
                  in other formats.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.arch" xreflabel="arch">
							<entry role="tagname">arch</entry>
							<entry>
								Set target CPU architecture. Note that this is not portable
								and should be avoided if possible. Accepted values are
								<literal>i[3456]86</literal>.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>


						<row id="tag.pic" xreflabel="pic">
							<entry role="tagname">pic</entry>
							<entry>
								Tells the compiler whether to generate position-independent
								code or not. The default is to use PIC for DLLs and
								<emphasis>not</emphasis> use it for executables and static
								libraries, but you may want to change it if your static
								library may be linked into a DLL.
								Accepted values are
								<literal>on</literal> and <literal>off</literal>.
							</entry>
							<entry role="availability">exe, lib</entry>
						</row>


						<row id="tag.threading" xreflabel="threading">
							<entry role="tagname">threading</entry>
							<entry>
								Use <literal>multi</literal> to enable and
								<literal>single</literal> to disable multithreading in the
								application. This affects what libraries are linked into
								executable on some platforms.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.warnings" xreflabel="warnings">
							<entry role="tagname">warnings</entry>
							<entry>
								Sets warnings level for C/C++ compiler. Possible values
								are <literal>no</literal>, <literal>default</literal>
								and <literal>max</literal>.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>


						<row id="tag.precomp-headers" xreflabel="precomp-headers">
							<entry role="tagname">precomp-headers</entry>
							<entry>
								Can be <literal>on</literal> or <literal>off</literal>,
								enables or disables use of precompiled headers with
								compilers that support them.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.precomp-headers-file"
							xreflabel="precomp-headers-file">
							<entry role="tagname">precomp-headers-file</entry>
							<entry>
								Use this tag to fine-tune where precompiled headers are
								stored. The compiler must support this and the value passed
								to <function>precomp-headers-file</function> can be modified
								by Bakefile, e.g. by apending <literal>.pch</literal>
								extension to it.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.precomp-headers-gen"
							xreflabel="precomp-headers-gen">
							<entry role="tagname">precomp-headers-gen</entry>
              <entry>
                For compilers that support it, specify which source file
                should be used to generate precompiled headers.
								<programlisting><![CDATA[
<exe id="myapp">
  <sources>foo.cpp bar.cpp</sources>
  <precomp-headers>on</precomp-headers>
  <precomp-headers-gen>foo.cpp</precomp-headers-gen>
  <precomp-headers-header>mypch.h</precomp-headers-header>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.precomp-headers-header"
							xreflabel="precomp-headers-header">
							<entry role="tagname">precomp-headers-header</entry>
              <entry>
                For compilers that support it, specify which header file
                should be used as the precompiled header. Typically, this
                header must be the first header included and it must be
                included by all source files. Some compilers (GCC in
                particular) ignore this, because they use different PCH model.
								<programlisting><![CDATA[
<exe id="myapp">
  <sources>foo.cpp bar.cpp</sources>
  <precomp-headers>on</precomp-headers>
  <precomp-headers-gen>foo.cpp</precomp-headers-gen>
  <precomp-headers-header>mypch.h</precomp-headers-header>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.cxx-rtti" xreflabel="cxx-rtti">
							<entry role="tagname">cxx-rtti</entry>
							<entry>
								Enable or disable RTTI when compiling C++ sources. Can be either
								<literal>on</literal> or <literal>off</literal>.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row id="tag.cxx-exceptions" xreflabel="cxx-exceptions">
							<entry role="tagname">cxx-exceptions</entry>
							<entry>
								Enable or disable C++ exceptions handling. Can be either
								<literal>on</literal> or <literal>off</literal>.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						<row>
							<entry role="tagname">
								<para id="tag.cflags">cflags</para>
								<para id="tag.cxxflags">cxxflags</para>
								<para id="tag.cppflags">cppflags</para>
							</entry>
							<entry>
								Add <emphasis>compiler dependent</emphasis> compilation
								flags to compiler flags.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row>
							<entry role="tagname">
								<para id="tag.ldflags" xreflabel="ldflags">ldflags</para>
							</entry>
							<entry>
								Add <emphasis>linker dependent</emphasis>
								flags for the linker.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						<row>
							<entry role="tagname">
								<para id="tag.ldlibs">ldlibs</para>
							</entry>
							<entry>
								Same as <xref linkend="tag.ldflags"/>, but adds the flags
								<emphasis>after</emphasis> all flags specified using
								<function>ldflags</function>. This is useful when resolving
								command line order problems that gcc is prone to.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
						
						
						<row id="tag.win32-res" xreflabel="win32-res">
							<entry role="tagname">win32-res</entry>
							<entry>
								Sets win32 resource (.rc) file for executable or DLL.
								The tag does nothing on platforms other than Windows.
								Compilation of the resource respects 
								<xref linkend="tag.define"/> and 
								<xref linkend="tag.include"/> tags on the target,
								as well as their resource specific counterparts
								<xref linkend="tag.res-define"/> and
								<xref linkend="tag.res-include"/>.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
						
						
						<row id="tag.mac-res" xreflabel="mac-res">
							<entry role="tagname">mac-res</entry>
							<entry>
								Sets Mac resource (.r) file for executable or DLL.
								The tag does nothing on platforms other than Mac.
								Compilation of the resource respects 
								<xref linkend="tag.define"/> and 
								<xref linkend="tag.include"/> tags on the target,
								as well as their resource specific counterparts
								<xref linkend="tag.res-define"/> and
								<xref linkend="tag.res-include"/>.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
						
						<row id="tag.symbian-res" xreflabel="symbian-res">
							<entry role="tagname">symbian-res</entry>
							<entry>
								Sets Symbian resource file for executable or DLL.
								The tag does nothing on platforms other than Symbian.
								Compilation of the resource respects 
								<xref linkend="tag.define"/> and 
								<xref linkend="tag.include"/> tags on the target,
								as well as their resource specific counterparts
								<xref linkend="tag.res-define"/> and
								<xref linkend="tag.res-include"/>.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
						
						
						<row id="tag.res-include" xreflabel="res-include">
							<entry role="tagname">res-include</entry>
							<entry>
								Similar to <xref linkend="tag.include"/>, but applies only
								to resources (<xref linkend="tag.mac-res"/>,
								<xref linkend="tag.win32-res"/>) and not to C/C++ sources.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
		
		
						<row id="tag.res-define" xreflabel="res-define">
							<entry role="tagname">res-define</entry>
							<entry>
								Similar to <xref linkend="tag.define"/>, but applies only
								to resources (<xref linkend="tag.mac-res"/>,
								<xref linkend="tag.win32-res"/>) and not to C/C++ sources.
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>
						
						
						<row id="tag.clean-files" xreflabel="clean-files">
							<entry role="tagname">clean-files</entry>
							<entry>
								Adds files to list of files that are cleaned when
								<command>make clean</command> is run -- i.e. files created
								while building the target.
							</entry>
							<entry role="availability">all</entry>
						</row>
						
						
						
						<row id="tag.install-to" xreflabel="install-to">
							<entry role="tagname">install-to</entry>
							<entry>
								If used, then the target is installed into directory
								specified as tag's value by <command>make install</command>
                (and uninstalled from there by the
                <command>make uninstall</command> target).
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>

            <row id="tag.install-headers-to" xreflabel="install-headers-to">
                <entry role="tagname">install-headers-to</entry>
                <entry>
                    If used, then the headers (see <xref linkend="tag.headers"/> tag)
                    of the target are installed into the directory
                    specified as tag's value by <command>make install</command>
                    (and uninstalled from there by the
                    <command>make uninstall</command> target).
                </entry>
                <entry role="availability">exe, dll, module, lib</entry>
            </row>
						
						<row id="tag.install-if" xreflabel="install-if">
							<entry role="tagname">install-if</entry>
							<entry>
								Install (see <xref linkend="tag.install-to"/>
								the target conditionally. The value must be well-formed
								condition.
								<programlisting><![CDATA[
<option name="INSTALL_HELLO">
  <values>0,1</values>
  <default-value>1</default-value>
</option>
<exe id="hello">
  <sources>hello.c</sources>
  <install-to>$(BINDIR)</install-to>
  <install-if>INSTALL_HELLO=='1'</install-if>
</exe>
]]></programlisting>
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
						
						
						
						<row id="tag.postlink-command" xreflabel="postlink-command">
							<entry role="tagname">postlink-command</entry>
							<entry>
								Use this tag to specify command(s) that must be executed
								after the target is linked. This can be used to e.g. add
								resources or strip debugging information.
							</entry>
							<entry role="availability">exe, dll, module, lib</entry>
						</row>
			
		
						<row id="tag.uid" xreflabel="uid">
							<entry role="tagname">uid</entry>
							<entry>
								Defines target's unique ID number for formats that need it.
								<emphasis>FIXME: currently not implemented in any format;
								document use of type=symbian1 etc. once it is used by
								something</emphasis>
							</entry>
							<entry role="availability">exe, dll, module</entry>
						</row>


            <row id="tag.msvc-guid" xreflabel="msvc-guid">
							<entry role="tagname">msvc-guid</entry>
							<entry>
                (Visual C++ project formats only.) Sets project's GUID.
							</entry>
							<entry role="availability">exe, lib, dll, module</entry>
						</row>
		
					</tbody>
				</tgroup>
			</informaltable>
						
						
			
			
			<note>
				<title>Autoconf Note</title>
				<para>
					Many configuration options listed above are not supported by the
					Autoconf format (e.g. <xref linkend="tag.optimize"/>,
					<xref linkend="tag.debug-info"/> or <xref linkend="tag.arch"/>.
					This is because <filename>configure</filename> is used to find
					appropriate compiler flags.
				</para>
			</note>

		</para>

	</section>
  
</chapter>
